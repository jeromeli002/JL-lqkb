
#ifdef OLED_ENABLE
#include "konglong.c"  // render_anime.c render_anime2.c render_anime3.c 分别为三种种大小不同OLED的待机动画，选择加载
// #include <stdio.h>
// [Init Variables] ----------------------------------------------------------//

 #include "logo.c"      //层logo标志
static uint32_t oled_timer          = 0;      // OLED 计时器
bool            master_oled_cleared = false;  // OLED CLEAR 标记
#define OLED_SHOW_STATE_TIMEOUT 30000         // 无操作10秒后激活OLED动画

static const char PROGMEM jlkb[] = {
0xff, 0x01, 0x01, 0x01, 0x01, 0x81, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xf1, 0xe1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0x81, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x81, 0x81, 0x41, 0x41, 
0x41, 0xc1, 0xc1, 0xc1, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x81, 0xc1, 0x41, 0x41, 
0xc1, 0xc1, 0x81, 0x01, 0x01, 0x01, 0x01, 0x01, 0x81, 0x81, 0x81, 0x41, 0x41, 0xc1, 0xc1, 0xc1, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x41, 0xc1, 0xc1, 0x41, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x81, 0x81, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0xc1, 0xc1, 0x81, 0x01, 0x01, 0x01, 0x01, 0xff, 
0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf3, 0x61, 0x61, 0x73, 0xff, 0xf3, 0xe3, 0xe1, 0xf3, 
0x7f, 0xff, 0xf3, 0xe1, 0xf3, 0x7f, 0x7f, 0xf3, 0xe1, 0xf3, 0xff, 0x7f, 0x73, 0xe1, 0xf3, 0xf7, 
0xff, 0x73, 0xe1, 0xe1, 0xf3, 0xf3, 0x7f, 0x73, 0x61, 0x61, 0xf3, 0xff, 0xff, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x1b, 0x01, 0x00, 0x00, 0x80, 
0xf0, 0x7f, 0x0f, 0x01, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xfc, 0x3e, 0x07, 0x01, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x1b, 0x01, 0x00, 0x00, 0x80, 0xf8, 0x7f, 0x67, 0xe0, 
0xf0, 0x18, 0x08, 0x04, 0x02, 0x03, 0x01, 0x00, 0x00, 0x00, 0xc0, 0x70, 0x0c, 0x06, 0x03, 0x01, 
0x00, 0x00, 0xf2, 0xfe, 0x7e, 0x43, 0x40, 0x60, 0xf0, 0xdd, 0x9f, 0x07, 0x00, 0x00, 0x00, 0xff, 
0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7f, 0x3c, 0x18, 0x38, 0x78, 0xfc, 0xfd, 0x7f, 0x3f, 0x1c, 
0x18, 0x18, 0x1d, 0x1f, 0x1c, 0x18, 0x18, 0x1c, 0x1f, 0x1d, 0x18, 0x18, 0x18, 0x1c, 0x1f, 0x1d, 
0x18, 0x18, 0x1c, 0x3f, 0x7f, 0xfc, 0x78, 0x38, 0x18, 0x18, 0x3c, 0x7f, 0xff, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xfc, 0x3f, 
0x07, 0x00, 0x00, 0x80, 0x80, 0xc0, 0xe0, 0xfe, 0x9f, 0xc1, 0xc0, 0xc0, 0xc0, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x70, 0x30, 0x00, 0x00, 0x00, 0x80, 0x80, 0xc0, 0xfc, 0xff, 0x87, 0x80, 0x00, 0x01, 
0x07, 0x3f, 0xf8, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0c, 0x88, 0x80, 0xc0, 
0xf0, 0xfe, 0x9f, 0x81, 0x80, 0x80, 0xc0, 0x40, 0x70, 0x3f, 0x1f, 0x06, 0x00, 0x00, 0x00, 0xff, 
0xff, 0x80, 0x80, 0x80, 0x81, 0x83, 0x87, 0x86, 0x86, 0x86, 0x87, 0x87, 0x87, 0x87, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x87, 0x87, 0x87, 0x86, 0x86, 0x86, 0x86, 0x83, 0x81, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x86, 0x86, 0x8c, 0x8c, 0x8c, 0x84, 0x83, 0x81, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x83, 0x87, 0x8c, 0x88, 0x88, 0x88, 0x88, 0x8e, 0x86, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xff, 
    };

static void print_status_narrow(void) {
    // Print current mode
  /*  oled_write_ln_P(PSTR("LAYER\n"), false);

    switch (get_highest_layer(layer_state)) {
        case 0:
            oled_write_ln_P(PSTR("00"), false);
            break;
        case 1:
            oled_write_ln_P(PSTR("01"), false);
            break;
        default:
            oled_write_ln_P(PSTR("02\n"), false);
            break;
    }
    oled_write_ln_P(PSTR("\n\n"), false);
    // Print current layer
    oled_write_ln_P(PSTR("mode\n"), false);*/
switch (get_highest_layer(layer_state)) {
        case 0:
 //         oled_set_cursor(1, 0);
            oled_write_raw_P(a01, sizeof(a01));
            break;
        case 1:
            oled_write_raw_P(a02, sizeof(a02));
            break;
        case 2:
            oled_write_raw_P(a03, sizeof(a03));
            break;
        case 3:
            oled_write_raw_P(a04, sizeof(a04));
            break;
        case 4:
            oled_write_raw_P(a05, sizeof(a05));
            break;
        case 5:
            oled_write_raw_P(a06, sizeof(a06));
            break;
        case 6:
            oled_write_raw_P(a07, sizeof(a07));
            break;           
        case 7:
            oled_write_raw_P(a08, sizeof(a08));
            break;          
        case 8:
            oled_write_raw_P(a09, sizeof(a09));
            break;         
        case 9:
            oled_write_raw_P(a10, sizeof(a10));
            break;           
        case 10:
            oled_write_raw_P(a11, sizeof(a11));
            break;           
        case 11:
            oled_write_raw_P(a12, sizeof(a12));
            break;         
        case 12:
            oled_write_raw_P(a13, sizeof(a13));
            break;           
        case 13:
            oled_write_raw_P(a14, sizeof(a14));
            break;           
        case 14:
            oled_write_raw_P(a15, sizeof(a15));
            break;           
        case 15:
            oled_write_raw_P(a16, sizeof(a16));
            break;             
 /*       case 5:
            render_anime();          
            break;
            */
        default:
            oled_write_ln_P(PSTR("Undef"), false);
    }
    /*
    oled_write_ln_P(PSTR(" "), false);
    oled_write_ln_P(PSTR("LED\n"), false);
    oled_write_P(host_keyboard_led_state().caps_lock ? PSTR("--A--\n") : PSTR("--a--\n"), false);
    oled_write_P(host_keyboard_led_state().num_lock ? PSTR("-Num-\n") : PSTR("-----\n"), false);
    oled_write_P(host_keyboard_led_state().scroll_lock ? PSTR("--S--\n") : PSTR("-- --\n"), false); */
}

oled_rotation_t oled_init_user(oled_rotation_t rotation) {
    if (is_keyboard_master()) {
        return OLED_ROTATION_180;
    }
    return rotation;
}
// {按键记录进程} ------------------------------------------------------//
bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    if (record->event.pressed) {
#ifdef OLED_ENABLE
        oled_timer = timer_read32();
#endif
    }
    return true;
}


bool oled_task_user(void) {
     if (timer_elapsed32(oled_timer) > OLED_SHOW_STATE_TIMEOUT && timer_elapsed32(oled_timer) < 1200000) {
        // 无操作10秒后，OLED_TIMEOUT(60秒默认)前播放动画
        if (!master_oled_cleared) {
            // Clear OLED一次确保动画正确渲染
            oled_clear();
            master_oled_cleared = true;
        }
        render_anime();
        return false;
    } else if (timer_elapsed32(oled_timer) > 1200000) {
        // 无操作60秒后关闭OLED
        oled_off();
        return false;
    } else {
        // 重置Clear OLED标记
        if (master_oled_cleared) {
            oled_on();
            oled_clear();
            master_oled_cleared = false;
        }
        print_status_narrow();

  }return false;
 /*   if (is_keyboard_master()) {
        print_status_narrow();
    } else {
 //     render_logo();
    render_anime();
    }
	return false;*/
}

#endif
